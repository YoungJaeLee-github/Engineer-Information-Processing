### 3. 애플리케이션 설계
#### 소프트웨어 아키텍처
* 소프트웨어의 골격이 되는 기본 구조이자 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
* 소프트웨어 개발 시 적용되는 원칙과 지침
##### 모듈화(Modularity)
* 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지관리 등 이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
* 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 듬
##### 추상화(Abstraction)
* 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것
* 추상화의 유형 : 과정 추상화, 데이터 추상화, 제어 추상화
##### 단계적 분해
##### 정보 은닉
##### 소프트웨어 아키텍처의 품질 속성
###### 시스템 측면
* 성능
* 보안
* 가용성
* 기능성
* 사용성 
* 변경 용이성
* 확장성
* 테스트 용이성, 배치성, 안정성 등
###### 비즈니스 측면
* 시장 적시성
* 비용과 혜택
* 예상 시스템 수명
###### 아키텍처 측면
* 개념적 무결성
* 정확성, 완결성
* 구축 가능성
##### 소프트웨어 아키텍처의 설계 과정
* 1. 설계 목표 설정 : 전체 시스템의 설계 목표를 설정함
* 2. 시스템 타입 결정 : 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
* 3. 아키텍처 패턴 적용
* 4. 서브시스템 구체화
* 5. 검토

#### 아키텍처 패턴
* 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
* 아키텍처 패턴을 아키텍처 스타일 또는 표준 아키텍처라고 함
##### 아키텍처 패턴의 장점
* 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있음.
* 검증된 구조로 개발하기 때문에 안정적인 개발이 가능함
* 이해관계자들이 공통된 아케틱처를 공유할 수 있어 의사소통이 간편해짐
* 시스템의 구조를 이해하는 것이 쉬움
* 시스템의 특성을 개발 전에 예측하는 것이 가능해짐
##### 레이어 패턴
* 레이어 패턴은 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나
* 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며, 변경사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이
* 레이어패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능함
* 대표적으로 OSI 참조 모델이 있음
##### 클라이언트-서버 패턴
* 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
* 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지
* 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적
##### 파이프-필터 패턴
* 파이프 필터 패턴은 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화 하여 파이프를 통해 데이터를 전송하는 패턴
* 파이프 필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용
* 대표적으로 UNIX의 쉘
##### 모델-뷰-컨트롤러 패턴(MVC)
* 모델 : 서브시스템의 핵심 기능과 데이터를 보관
* 뷰 : 사용자에게 정보를 표시
* 컨트롤러 : 사용자로부터 받은 입력을 처리
* 한 개의 모델에 대해 여러개의 뷰를 필요로 하는 대화형 애플리케이션에 적합함
##### 기타 패턴
* 마스터 슬레이브 패턴 : 장애 허용, 병렬 컴퓨팅에 많이 쓰임
* 브로커 패턴 : 분산 환경 시스템에 주로 활용
* 피어 투 피어 패턴 : 멀티스레딩 방식을 사용
* 이벤트 버스 패턴 
* 블랙보드 패턴
* 인터프리터 패턴

#### 객체지향(Object-Oriented)
* 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법
* 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있음
* 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다
* 객체, 클래스, 캡슐화, 상속, 다형성이 있다.
##### 객체
* 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈
* 데이터 : 속성, 상태, 변수, 상수, 자료구조 라고도 함
* 함수 : 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
###### 객체의 특성
* 객체는 독립적으로 식별 가능한 이름을 가지고 있음
* 조건을 상태(State)라고 하는데, 일반적으로 상태는 시간에 따라 변함
* 객체와 객체는 상호 연관성에 의한 관계가 형성됨
* 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타냄
* 객체는 일정한 기억장소를 가지고 있음
* 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행함
##### 클래스
* 공통된 속성과 연산을 갖는 객체의 집합
* 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
* 클래스에 속한 각각의 객체를 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 함
* 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미
* 슈퍼 클래스는 특정 클래스의 상위 클래스이고, 서브 클래스는 특정 클래스의 하위 클래스를 의미
##### 캡슐화(Encapsulation)
* 캡슐화는 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적음
* 재사용이 용이함
* 인터페이스가 단순해지고, 객체 간의 결합도가 낮아짐
##### 상속(Inheritance)
* 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있음
* 하위클래스는 상위클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있음
* 다중 상속 : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것
##### 다형성(Polymorphism)
* 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미함
* 동일한 메소드명을 사용하며 같은 의미의 응답을 함
#### 모듈
* 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨
* 모듈은 단독으로 컴파일이 가능하며, 재사용 할 수 있음
* 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미하는 것, 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어짐
* 모듈의 독립성은 결합도와 응집도에 의해 측정됨
* 모듈의 결합도는 약하게, 응집도는 강하게 해야 함
##### 결합도(Coupling)
* 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미함
* 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음
* 자료 결합도
* 스탬프 결합도
* 제어 결합도
* 외부 결합도
* 공통 결합도
* 내용 결합도
##### 응집도(Cohesion)
* 응집도는 정보 은닉 개념을 확장한 것으로 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도
* 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음
* 기능적 응집도
* 순차적 응집도
* 교환적 응집도
* 절차적 응집도
* 시간적 응집도
* 논리적 응집도
* 우연적 응집도
##### 팬인 팬 아웃
* 팬인은 어떤 모듈을 제어하는 모듈의 수 : 들어오는 수
* 팬 아웃은 어떤 모듈에 의해 제어되는 모듈의 수 : 나가는 수
* 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계 해야 함
#### 코드
* 컴퓨터를 이용해 자료를 처리하는 과정에서 분류 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호
* 정보를 신속 정확 명료하게 전달할 수 있음
* 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미침
* 주민등록번호, 학번, 전화번호 등이 있음
* 식별 기능, 분류 기능, 배열 기능
##### 코드의 종류
* 순차 코드
* 블록 코드
* 10진 코드
* 그룹 분류 코드
* 연상 코드
* 표의 숫자 코드
* 합성 코드
##### 코드 부여 체계
* 이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식
* 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 함

#### 디자인 패턴
* 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
* GoF라고 불리는 에릭 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스가 처음으로 구체화 및 체계화함
* 생성 패턴 5개, 구조 패턴7개, 행위 패턴 11개 총 23개의 패턴으로 구성 됨
##### 아키텍처 패턴 vs 디자인 패턴
* 아키텍처 패턴이 더 상위 수준의 설계에 사용됨
* 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면 디자인 패턴은 서브 시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
##### 생성 패턴(Creational Pattern)
* 객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있음
* 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해줌
* 추상 팩토리 : 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함
* 빌더 : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함
* 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
* 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
* 싱글톤 : 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있음
##### 구조 패턴(Structural Pattern)
* 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 총 7개의 패턴
* 구조가 복잡한 시스템을 개발하기 쉽게 도와줌
* 어댑터 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
* 브리지 : 기능과 구현을 두 개의 별도 클래스로 구현
* 컴포지트 : 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음
* 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
* 퍼싸드 : 복잡한 서브 클래스 들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
* 플라이웨이트 : 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
* 프록시 : 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용
##### 행위 패턴(Behavioral Pattern)
* 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 총 11개의 패턴이 있음
* 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
* 커맨드 : 각종 명령어 들을 추상 클래스와 구체 클래스로 분리하여 단순화 함
* 인터프리터 : 언어에 문법 표현을 정의 하는 패턴
* 반복자 : 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
* 중재자 : 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
* 메멘토 : 특정 시점에서의 객체 내부 상태를 객체화 함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 되돌릴 수 있는 기능을 제공하는 패턴
* 옵서버 : 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
* 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
* 전략 : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
* 템플릿 메소드 : 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
* 방문자 : 분리된 처리 기능은 각 클래스를 방문하여 수행함
